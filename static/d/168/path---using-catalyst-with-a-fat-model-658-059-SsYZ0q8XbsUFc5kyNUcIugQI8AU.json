{"data":{"site":{"siteMetadata":{"title":"For next time","author":"Jason Galea"}},"markdownRemark":{"id":"1a75e63f-fbfc-5601-bfe6-298081efffcf","excerpt":"Today I’m going to talk about using a fat model in Catalyst. When I started using Catalyst and eventually got my head around all the parts…","html":"<p>Today I’m going to talk about using a fat model in Catalyst. When I started using Catalyst and eventually got my head around all the parts and where they all fit in, the slot for my “business logic” seemed to be in the Controllers and I think that’s a common assumption.</p>\n<p>The first thing that got my spidey sense tingling about this approach was when I realised I had multiple Actions with the same code. I’m very, very DRY so that bugged me a lot. Because I was in a Controller my first attempts at fixing this resulted in lots of forwarding between Actions both private and not.. this gets very messy, very quickly.</p>\n<p>Ok, so why not regular methods in the Controllers which are called from your Actions? This is a better solution wherever possible but I must admit it makes me feel icky.. a Controller is a place for Actions and for clarity, modularity, etc, I prefer to keep everything else out..</p>\n<p>To this end I looked to the model, the next (first?) obvious place to put these common methods. At this stage I was still trying to fit my code into Catalyst and made a couple of attempts at small Models for targeted functionality but then ran into issues from wanting access from one Model to another. At the same time I also discovered the issues involved in accessing Catalyst code from cron scripts and the like..</p>\n<p>ok, finally, my current solution? the fat Model. Essentially it’s your whole app wrapped up in it’s own nice “little” module..</p>\n<h3>My App</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">package My::App;\nuse Moose;\n\nhas &#39;config&#39;    =&gt; ( isa =&gt; &#39;My::App::Config&#39;, is =&gt; &#39;ro&#39;, required =&gt; 1 );\n\nhas &#39;schema&#39;    =&gt; ( isa =&gt; &#39;DBIx::Class::Schema&#39;, is =&gt; &#39;ro&#39;, required =&gt; 1 );\n\nhas &#39;template&#39; =&gt; ( isa =&gt; &#39;Template&#39;, is =&gt; &#39;ro&#39; );\n\nhas &#39;visitor&#39; =&gt; ( isa =&gt; &#39;My::App::Visitor&#39;, is =&gt; &#39;ro&#39; );\n\nhas &#39;products&#39; =&gt; ( isa =&gt; &#39;My::App::Products&#39;, is =&gt; &#39;ro&#39;, lazy_build =&gt; 1 );\n\nsub _build_products{\n    My::App::Products-&gt;new({ schema =&gt; $_[0]-&gt;schema });\n}</code></pre></div>\n<p>With this as an entry point I can easily write a script which uses this class to access the full functionality of my app. I’ve also skipped a lot of coercing and auto-building in this example which you can use to make things even simpler.</p>\n<p>ok, but I thought we were talking about Models?</p>\n<h3>My App Model</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    package My::Catalyst::Model::MyApp;\n    use Moose;\n    extends &#39;Catalyst::Model::Factory::PerRequest&#39;;\n\n    __PACKAGE__-&gt;config( class =&gt; &#39;My::App&#39; );\n\n    # Instantiate the main app for each request.\n    sub prepare_arguments {\n        my ($self, $c) = @_;\n\n        my $args = $c-&gt;config-&gt;{&#39;Model::MyApp&#39;}{args};\n\n        $args-&gt;{template} = $c-&gt;view(&#39;TT&#39;)-&gt;template;\n        $args-&gt;{schema} = $c-&gt;model(&#39;DB&#39;)-&gt;schema;\n\n        $c-&gt;session unless $c-&gt;sessionid;\n\n        my $visitor = { session_id =&gt; $c-&gt;sessionid };\n        $visitor-&gt;{user} = $c-&gt;user if $c-&gt;user_exists;\n\n        $args-&gt;{visitor} = My::App::Visitor-&gt;new($visitor);\n\n        return $args;\n    }\n\n    no Moose;\n    __PACKAGE__-&gt;meta-&gt;make_immutable();\n\n    1;</code></pre></div>\n<p>With this model in my Catalyst app I can now access my main app from wherever I need within the Catalyst system via $c->model(‘MyApp’). I’m also reusing things that Catalyst makes simple like my database model and template object. I use the template object when creating system emails in my app and there’s no reason to instantiate a new Template object each time, and I can set it up once and know the same instance will be used everywhere.</p>\n<h3>My Controller</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    package My::Catalyst::Controller::Root;\n    use Moose;\n    use namespace::autoclean;\n\n    BEGIN { extends &#39;Catalyst::Controller&#39; }\n\n    __PACKAGE__-&gt;config(namespace =&gt; &#39;&#39;);\n\n    sub index : Local{\n        my ( $self, $c ) = @_;\n\n        my $app = $c-&gt;model(&#39;MyApp&#39;);\n\n        $c-&gt;stash({\n            template =&gt; &#39;index.tt&#39;,\n            latest_products =&gt; $app-&gt;products-&gt;latest\n        });\n    }</code></pre></div>\n<p>Now I can use Catalyst for all the wonderful things it makes so easy while keeping my main app nicely separated from it. Oh, and just quietly.. if the sky turned green and I needed to set up a quick Dancer or Mojolicious app I could do that quite easily too..</p>\n<p><em>update: well, look at that sky.. 8) for my latest project, <a href=\"https://pdfunicorn.com\">PDFUnicorn</a> I’ve chosen to go with <a href=\"http://mojolicio.us/\">Mojolicious</a> for it’s non-blocking goodness. (interesting to note the similarities with the <a href=\"http://expressjs.com/\">Express</a> framework for <a href=\"http://nodejs.org/\">Node.js</a>, the current darling of modern web dev).</em></p>","frontmatter":{"title":"Using Catalyst with a Fat Model","date":"December 04, 2011"}}},"pageContext":{"slug":"/using-catalyst-with-a-fat-model/","previous":null,"next":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"Hello World"}}}}